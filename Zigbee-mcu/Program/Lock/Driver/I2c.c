#define I2C_C_

/* ------------------------------------------------------------------------------------------------
 *                                          Includes
 * ------------------------------------------------------------------------------------------------
 */
#include "I2c.h"


/**************************************************************************************************
 * @fn          I2C_Init
 * @brief       I2C端口设置
 * @param       无
 * @return      无
 **************************************************************************************************
 */
void I2C_Init(void)
{
  P1DIR |= 0x0C;    //P1_2、P1_3设置为输出
}

/**************************************************************************************************
 * @fn          I2C_Delay
 * @brief       I2C延时函数
 * @param       n
 * @return      无
 **************************************************************************************************
 */
void I2C_Delay(uint8_t n)
{
  uint8_t i;
  for (i=0; i<n; i++)
  {
    asm("nop");
    asm("nop");
    asm("nop");
    asm("nop");
  }
}

/**************************************************************************************************
 * @fn          I2C_Start
 * @brief       启动I2C总线子程序
 * @param       无
 * @return      无
 **************************************************************************************************
 */
void I2C_Start(void)
{           
  I2C_SDA_OUT();    
  /*时钟保持高，数据线从高到低一次跳变，I2C通信开始*/
  SDA = 1;        //发送起始条件的数据信号
  I2C_Delay(2);   
  SCL = 1;        //发送起始条件的时钟信号
  I2C_Delay(4);   //起始条件建立时间大于4.7us,延时
  SDA = 0;        
  I2C_Delay(4);   //起始条件锁定时间大于4μs 
  SCL = 0;        //钳住I2C总线，准备发送或接收数据,发送数据时时钟信号为高电平并且SDA要保持稳定
  I2C_Delay(2); 
}


/**************************************************************************************************
 * @fn          I2C_Stop
 * @brief       停止I2C总线数据传送子程序
 * @param       无
 * @return      无
 **************************************************************************************************
 */
void I2C_Stop(void)
{
  I2C_SDA_OUT();
 
  SDA = 0;         //发送结束条件的数据信号
  I2C_Delay(2);
  SCL = 1;         //发送结束条件的时钟信号
  I2C_Delay(4); 
  SDA = 1;         //发送I2C总线结束信号
  I2C_Delay(4); 
  SCL = 0;         //钳住I2C总线，准备发送或接收数据
  I2C_Delay(2); 
}


/**************************************************************************************************
 * @fn          I2C_ReceiveAck
 * @brief       接收ACK应答数据
 * @param       无
 * @return      应答标志：0 有应答 1 无应答
 **************************************************************************************************
 */
uint8_t I2C_ReceiveAck(void)
{
  I2C_SDA_IN();
  I2C_Delay(1);
  
  if(SDA == 0)      //若SDA = 0 表示有应答，同时接收数据的时候也有用到
  {
    return 0;
  }
  else
  {
    return 1; 
  }
}

/**************************************************************************************************
 * @fn          I2C_SendByte
 * @brief       字节数据传送
 * @param       Tx          -> 数据传送字
 * @return      I2C_AckFlag -> 应答标志：0 有应答 1 无应答
 **************************************************************************************************
 */
uint8_t I2C_SendByte(uint8_t I2C_Tx)
{
  uint8_t I2C_BitCnt;
  uint8_t I2C_AckFlag;  
  for(I2C_BitCnt=0; I2C_BitCnt<8; I2C_BitCnt++)   //要传送的数据长度为8位
  {
    I2C_SDA_OUT();
    if((I2C_Tx << I2C_BitCnt) & 0x80)         //判断发送位
    {
      SDA = 1; 
    }
    else
    {
      SDA = 0; 
    }
    I2C_Delay(1);  
    SCL = 1;                          //置时钟线为高，通知被控器开始接收数据位
    I2C_Delay(4);                     //保证时钟高电平周期大于4μs
    SCL = 0;                          //SDA仅在时钟SCL为低电平时改变
  }
  
  I2C_Delay(2);
  SDA = 1;                            //8位发送完后释放数据线，准备接收应答位
  I2C_Delay(2);
  SCL = 1;  
  I2C_Delay(3);
  I2C_AckFlag = I2C_ReceiveAck();       //判断是否接收到应答信号
  SCL = 0;
  I2C_Delay(2);
  I2C_SDA_OUT();
  return I2C_AckFlag;
}


/**************************************************************************************************
 * @fn          I2C_ReveiveByte
 * @brief       字节数据接收
 * @param       无
 * @return      接收数据
 **************************************************************************************************
 */
uint8_t I2C_ReceiveByte(void)
{
  uint8_t  I2C_Rx;
  uint8_t  I2C_BitCnt;
  uint8_t  I2C_Ack;
  
  I2C_Rx = 0; 
  I2C_SDA_IN();         //置数据线为输入方式
  SDA = 1;            
  for(I2C_BitCnt=0; I2C_BitCnt<8; I2C_BitCnt++)
  {
    I2C_Delay(1);           
    SCL = 0;            //置时钟线为低，准备接收数据位
    I2C_Delay(4);  
    SCL = 1;            //置时钟线为高使数据线上数据有效
    I2C_Delay(2);
    I2C_Rx = I2C_Rx << 1;
    I2C_Ack = I2C_ReceiveAck();
    if (I2C_Ack == 1)
    {
      I2C_Rx = I2C_Rx + 1;      //读数据位,接收的数据位放入Rx中
    }
    I2C_Delay(2);        
  } 
  SCL = 0;    
  I2C_Delay(4);
  I2C_SDA_OUT();
  return I2C_Rx;
}


/**************************************************************************************************
 * @fn          I2C_SendAck
 * @brief       主控制器进行应答信号（可以是应答或非应答）
 * @param       应答标志 0 有应答 1 无应答
 * @return      无
 **************************************************************************************************
 */
void I2C_SendAck(uint8_t I2C_AckFlag)
{
  if(I2C_AckFlag == 0)
  {
    SDA = 0;
  }
  else
  {
    SDA = 1;
  }
  
  I2C_Delay(3);
  SCL = 1;
  I2C_Delay(4);
  SCL = 0;          //清时钟线，钳住I2C总线以便继续接收
  I2C_Delay(2);
}



